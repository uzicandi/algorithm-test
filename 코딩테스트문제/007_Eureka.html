<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>
  <body>
    <script>
      /* 1. 파이와 썬은 8이다.
              해당 행렬은 3차원으로, Cube 형태를 띄게된다.
              각 큐브에 새겨진 값은 가중치다.
              이 가중치를 더해 파이에서 썬으로 가는 최단거리를 구하고,
              최단 경로를 행렬의 좌표값으로 구해라. (해당형태가 cube임을 감안)
              */

      /*
              문제 푸는 방법
              1. graph로 바꿔 다익스트라 알고리즘 (어려움)
              2. matrix 형태의 동적 계획법
              - recursion, memorization을 통해 풀 수도 있지만
              여기서는 for문으로 푼다.
              */

      //   let cross = [
      //     [
      //       [1, 5, 0, 1, 0],
      //       [0, 1, 6, 7, 0],
      //       [6, 2, 3, 2, 1],
      //       [1, 0, 1, 1, 1],
      //       [0, 2, 0, 1, 0]
      //     ],
      //     [
      //       [0, 3, 0, 1, 0],
      //       [1, 2, 5, 4, 4],
      //       [0, 0, 3, 0, 0],
      //       [1, 2, 5, 0, 1],
      //       [0, 0, 0, 0, 0]
      //     ],
      //     [
      //       [3, 0, 1, 1, 8],
      //       [5, 0, 4, 5, 4],
      //       [1, 5, 0, 5, 1],
      //       [1, 2, 1, 0, 1],
      //       [0, 2, 5, 1, 1]
      //     ],
      //     [
      //       [1, 0, 3, 3, 3],
      //       [5, 1, 2, 2, 4],
      //       [1, 5, 1, 2, 4],
      //       [4, 4, 1, 1, 1],
      //       [4, 4, 1, 1, 1]
      //     ],
      //     [
      //       [1, 2, 0, 3, 3],
      //       [1, 2, 0, 2, 4],
      //       [1, 2, 0, 2, 4],
      //       [4, 2, 0, 0, 1],
      //       [8, 4, 1, 1, 0]
      //     ],
      //     [
      //       [1, 0, 3, 0, 0],
      //       [1, 1, 0, 2, 4],
      //       [0, 0, 1, 2, 4],
      //       [4, 0, 1, 0, 1],
      //       [0, 0, 1, 0, 1]
      //     ]
      //   ];

      let cross = [
        [
          [3, 0, 1, 1, 8],
          [5, 0, 4, 5, 4],
          [1, 5, 0, 5, 1],
          [1, 2, 1, 0, 1],
          [0, 2, 5, 1, 1]
        ],
        [
          [1, 2, 0, 3, 3],
          [1, 2, 0, 2, 4],
          [1, 2, 0, 2, 4],
          [4, 2, 0, 0, 1],
          [8, 4, 1, 1, 0]
        ]
      ];
      cross = cross.flat();
      console.log(cross.flat()); // array 하나가 벗겨지고 배열들이 합쳐짐.
      // depth도 넣어줄 수 있음. flat(2)라고 하면 array가 2번 벗겨지고 1차원 배열로 변함.

      // 작은 데이터로 테스트
      let c = [
        [3, 0, 1, 1, 8],
        [5, 0, 4, 5, 4],
        [1, 5, 0, 5, 1],
        [1, 2, 1, 0, 1],
        [0, 2, 5, 1, 1]
      ];

      // let 가중치누적값 = Array(5).fill(0); // [0, 0, 0, 0, 0] 인 1차원 array
      let 가중치누적값 = Array(5)
        .fill(0)
        .map(() => Array(5).fill(0)); // [0, 0, 0, 0, 0] 이 5개인 2차원 array
      console.log(가중치누적값);

      for (let i = 0; i < c.length; i++) {
        for (let j = 0; j < 5; j++) {
          if (i == 0 && j == 0) {
            가중치누적값[0][0] = c[0][0];
          } else if (i == 0) {
            가중치누적값[i][j] = 가중치누적값[i][j - 1] + c[i][j];
          } else if (j == 0) {
            가중치누적값[i][j] = 가중치누적값[i - 1][j] + c[i][j];
          } else {
            가중치누적값[i][j] =
              Math.min(가중치누적값[i][j - 1], 가중치누적값[i - 1][j]) +
              c[i][j];
          }
        }
      }
      console.log(c);
      console.log(가중치누적값);

      let 좌표저장 = Array(5) // [0,0]으로 되어있는 좌표들.
        .fill(0)
        .map(() =>
          Array(5)
            .fill(0)
            .map(() => Array(2).fill(0))
        );
      console.log(좌표저장);

      for (let i = 0; i < c.length; i++) {
        for (let j = 0; j < 5; j++) {
          if (i == 0 && j == 0) {
            가중치누적값[0][0] = c[0][0];
            좌표저장[0][0][0] = i;
            좌표저장[0][0][1] = j;
          } else if (i == 0) {
            가중치누적값[i][j] = 가중치누적값[i][j - 1] + c[i][j];
            좌표저장[i][j][0] = i;
            좌표저장[i][j][1] = j - 1;
          } else if (j == 0) {
            가중치누적값[i][j] = 가중치누적값[i - 1][j] + c[i][j];
            좌표저장[i][j][0] = i - 1;
            좌표저장[i][j][1] = j;
          } else {
            if (가중치누적값[i][j - 1] > 가중치누적값[i - 1][j]) {
              가중치누적값[i][j] = 가중치누적값[i - 1][j] + c[i][j];
              좌표저장[i][j][0] = i - 1;
              좌표저장[i][j][1] = j;
            } else {
              가중치누적값[i][j] = 가중치누적값[i][j - 1] + c[i][j];
              좌표저장[i][j][0] = i;
              좌표저장[i][j][1] = j - 1;
            }
          }
        }
      }
      console.log(좌표저장);
      console.log(cross);
    </script>
  </body>
</html>
